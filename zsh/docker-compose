export DC_SHELL_CONTAINER=${DC_SHELL_CONTAINER:-shell}

alias dc="docker compose"
alias dcps="docker compose ps -a --format \"table {{.ID}}\\t{{.Name}}\\t{{.Status}}\""
alias rubocop="dexec-shell rubocop $@"

function kill-dc-shell {
  dc ps -a | grep $DC_SHELL_CONTAINER | grep Up | cut -d\  -f1 | xargs docker rm -f
}

function grep-dc-shell {
  dc ps -a | grep $DC_SHELL_CONTAINER | grep Up | head -1 | cut -d' ' -f1
}

function grep-solargraph() {
  container=$(dc ps -a | grep solargraph-run- | grep Up | head -1 | cut -d' ' -f1)
  [ -n "$container" ] && echo $container || echo solargraph
}

function start-dc-shell() {
  if [ -f "$(dc-workdir)/docker-compose.yml" ]; then
    [ -n "$(grep-dc-shell)" ] || dc up -d $DC_SHELL_CONTAINER
  else
    echo "$(realpath $(dc-workdir))/docker-compose.yml doesn't exist" >&2
    return 1
  fi
}

function dexec-shell() {
  start-dc-shell || return 1
  [ -z "$(grep-dc-shell)" ] && echo "Failed to start shell container" && return 1
  (cd $(dc-workdir) && docker exec -ti -w $PWD/$(dc-subpath) $(echo $DEXEC_ARGV) $(grep-dc-shell) $@ && exit 1)
}

function dc-workdir() {
  [ -n "$(dc-subpath)" ] && echo '..' || echo '.'
}

function dc-subpath() {
  [ -f 'docker-compose.yml' ] && echo '' || echo $(basename $(pwd))
}

function vcr-env() {
  [ -n "$VCR$VCR_UP" ] && echo " -e VCR_UP=1"
}

function prof-env() {
  [ -n "$PROF" ] && echo " -e TEST_STACK_PROF=$PROF -e TEST_STACK_PROF_FORMAT=json"
}

function log-env() {
  [ -n "$LOG" ] && echo " -e LOG=$LOG"
}

function dc-test-env() {
  echo "-e ${DC_TEST_ENV:-APP_ENV=test}$(vcr-env)$(prof-env)$(log-env)"
}

function rspec() {
  dcwd=$(dc-subpath)
  pd=dcwd
  typeset -A pdfiles
  start-dc-shell || return 1
  bundle check | grep satisfied > /dev/null 2>&1 || bundle install

  for f in $@; do
    [ -z "$dcwd" ] && pd=$(echo $f | cut -d/ -f1 | grep -v spec) || pd="."
    pdfiles[$pd]="$pdfiles[$pd] ${f#$pd/}"
  done

  [ -z "$@" ] && pdfiles[.]=""

  for pd in ${(@k)pdfiles}; do
    dc_args="$(dc-test-env) $(grep-dc-shell) bundle exec rspec$pdfiles[$pd]"
    (cd $(dc-workdir) && docker exec -ti -w $PWD/$pd $(echo $dc_args))
    [ -n "$(vcr-env)" ] && sudo chown -R $USER $(dc-workdir)/$pd/spec/cassettes
  done
}

function psql() {
  docker exec -ti $(dc ps | grep $(basename $(pwd))_db | head -1 | cut -d' ' -f1) psql $@
}

function bundle() {
  if [ "$1" = "all" ]; then
    echo "#!/bin/bash

    find ./ -maxdepth 2 -name Gemfile | {
      while read str; do
        dir=\$(dirname \$str)
        cd \$dir && echo -\\>\$(pwd) && bundle && [ \$dir = '.' ] || cd .. && echo \$(pwd)
      done
    }" > $(dc-workdir)/.bundle-script

    chmod a+x $(dc-workdir)/.bundle-script
    (cd $(dc-workdir) && dexec-shell ./.bundle-script)
  else
    DEXEC_ARGV=$(dc-test-env) dexec-shell bundle $@
  fi
}

function rcop() {
  for branch in develop master main; do
    [ -z "$base_branch" ] && base_branch=$(git rev-parse --verify --symbolic -q $branch)
  done
  rcop_files=$(git diff origin/$base_branch..HEAD --name-only --diff-filter=dr | grep -E ".+\.(rb|jbuilder)")
  workdir=$(dc-workdir)
  echo "#!/bin/bash\necho \"$rcop_files\" | xargs bundle exec rubocop $@" > $workdir/.rcop-script
  chmod a+x $workdir/.rcop-script
  project_dir=$(dc-subpath)
  (cd $(dc-workdir) && docker exec -i -w $PWD$project_dir $(grep-dc-shell) ./.rcop-script && exit 1)
}
