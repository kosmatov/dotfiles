alias dc="docker compose"
alias dcps="docker compose ps -a --format \"table {{.ID}}\\t{{.Name}}\\t{{.Status}}\""
alias rubocop="dexec-shell rubocop $@"

function kill-dc-shell {
  dc ps -a | grep $DC_SHELL_CONTAINER | grep Up | cut -d\  -f1 | xargs docker rm -f
}

function grep-dc-shell {
  dc ps -a | grep $DC_SHELL_CONTAINER | grep Up | head -1 | cut -d' ' -f1
}

function grep-solargraph() {
  container=$(dc ps -a | grep solargraph-run- | grep Up | head -1 | cut -d' ' -f1)
  [ -n "$container" ] && echo $container || echo solargraph
}

function start-dc-shell() {
  if [ -f "$DC_CONFIG_DIR/docker-compose.yml" ]; then
    [ -n "$(grep-dc-shell)" ] || dc up -d $DC_SHELL_CONTAINER
  else
    echo "$(realpath $DC_CONFIG_DIR/docker-compose.yml) doesn't exist" >&2
    return 1
  fi
}

function dexec-shell() {
  start-dc-shell || return 1
  [ -z "$(grep-dc-shell)" ] && echo "Failed to start shell container" && return 1
  docker exec -ti $DEXEC_ARGV $DC_SHELL_ARGS $(grep-dc-shell) $@
}

function dc-workdir() {
  workdir=$(dc config --format json | jq ".services.$DC_SHELL_CONTAINER.working_dir")
  [ "$workdir" = "null" ] && workdir=$(dc config --format json | jq -r ".services.$DC_SHELL_CONTAINER.volumes.[] | select(.source == \"$(pwd)\").target")
  [ -z "$workdir" ] && workdir=$(pwd)
  [ -n "$(dc-subpath)" ] && echo ${workdir:Q}/$(dc-subpath) || echo ${workdir:Q}
}

function dc-subpath() {
  [ -f 'docker-compose.yml' ] && echo '' || echo "/$(basename $(pwd))"
}

function vcr-env() {
  [ -n "$VCR$VCR_UP" ] && echo " -e VCR_UP=1"
}

function prof-env() {
  [ -n "$PROF" ] && echo " -e TEST_STACK_PROF=$PROF -e TEST_STACK_PROF_FORMAT=json"
}

function log-env() {
  [ -n "$LOG" ] && echo " -e LOG=$LOG"
}

function dc-test-env() {
  echo "-e ${DC_TEST_ENV:-APP_ENV=test}$(vcr-env)$(prof-env)$(log-env)"
}

function rspec() {
  dcwd=$(dc-subpath)
  pd=dcwd
  typeset -A pdfiles
  start-dc-shell || return 1
  bundle check | grep satisfied > /dev/null 2>&1 || bundle install
  dc_workdir=$(dc-workdir)

  for f in $@; do
    [ -z "$dcwd" ] && pd=$(echo $f | cut -d/ -f1 | grep -v spec) || pd="."
    pdfiles[/$pd]="$pdfiles[$pd] ${f#$pd/}"
  done

  [ -z "$@" ] && pdfiles[/.]=""

  for pd in ${(@k)pdfiles}; do
    dc_args="$DC_SHELL_ARGS $(dc-test-env) $(grep-dc-shell) bundle exec rspec$pdfiles[$pd]"
    cmd="docker exec -ti -w $dc_workdir$pd $dc_args"
    echo "$cmd"
    eval "$cmd"
    [ -n "$(vcr-env)" ] && sudo chown -R $USER $DC_CONFIG_DIR/$pd/spec/cassettes
  done
}

function psql() {
  docker exec -ti $(dc ps | grep $(basename $(pwd))_db | head -1 | cut -d' ' -f1) psql $@
}

function bundle() {
  if [ "$1" = "all" ]; then
    echo "#!/bin/bash

    find ./ -maxdepth 2 -name Gemfile | {
      while read str; do
        dir=\$(dirname \$str)
        cd \$dir && echo -\\>\$(pwd) && bundle && [ \$dir = '.' ] || cd .. && echo \$(pwd)
      done
    }" > $(dc-workdir)/.bundle-script

    chmod a+x $(dc-workdir)/.bundle-script
    (cd $(dc-workdir) && dexec-shell ./.bundle-script)
  else
    DEXEC_ARGV=$(dc-test-env) dexec-shell bundle $@
  fi
}

function rcop() {
  for branch in develop master main; do
    [ -z "$base_branch" ] && base_branch=$(git rev-parse --verify --symbolic -q $branch)
  done
  rcop_files=$(git diff origin/$base_branch..HEAD --name-only --diff-filter=dr | grep -E ".+\.(rb|jbuilder)")
  echo "#!/bin/bash\necho \"$rcop_files\" | xargs bundle exec rubocop $@" > $DC_CONFIG_DIR/.rcop-script
  chmod a+x $DC_CONFIG_DIR/.rcop-script
  cmd="docker exec -i -w $(dc-workdir)$(dc-subpath) $DC_SHELL_ARGS $(grep-dc-shell) ./.rcop-script"
  echo "$cmd"
  eval "$cmd"
}
